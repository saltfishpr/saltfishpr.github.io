---
title: 旧系统重写与数据迁移
date: 2023-11-11T01:10:22Z
author: Salt Fish
authorLink: https://github.com/saltfishpr
description: 旧系统重写与数据迁移
tags: []
categories: ["Programming"]

draft: true
---

<!--more-->

最近工作的内容是重写公司的会议室预定系统

旧系统是早期 C# 编写，部署在 Windows Server 上，代码即将无人维护{{< spoiler >}}（老员工要被优化了，笑）{{< /spoiler >}}

改造目标为使用 Java + SpringBoot 套件重写，部署在 k8s 集群中

## 设计兼容

兼容大部分原有的用户习惯，优化老系统的限制，如一次只能预定一间会议室的一个时间段

## 数据迁移

老系统很多功能已经废弃，需要对原来的表做减法，最终由 40+ 张表简化为 14 张表

老系统表的 ID 为自增 ID，新系统拟采用雪花算法生成 ID

为了平滑切换（能够两边操作），需要新老系统数据双向同步。同步数据使用 Kafka 异步消费消息的方式，暂不详细说明。

在表设计上有两种方案：

1.  新系统表在设计时，数据实体表增加一个唯一 ID 标识老系统中的 ID (EXT_ID)。

- 老系统创建数据时，推送新系统，新系统生成一个自己的主键并将 EXT_ID 存成老系统的 ID
- 老系统更新数据时，传老系统的 ID 推送新系统
- 新系统创建数据时，推送老系统，老系统**回调**新系统更新表中的 EXT_ID 字段
- 新系统更新数据时，传 EXT_ID 推送老系统

2.  如果实体具有**业务唯一字段**，如会议室名称唯一，则可以通过**业务唯一字段**反向查询当前系统中实体的唯一 ID

- 老系统创建数据时，推送名称给新系统
- 老系统更新数据时，推送 (旧名称，新名称) 给新系统
- 新系统创建数据时，推送名称给老系统
- 新系统更新数据时，推送 (旧名称，新名称) 给老系统

## 会议室资源锁

用于防止高并发场景下会议室“超卖”

会议室操作锁结构设计如下：

```plaintext
# roomId(key) -> hash table
roomId: {
  "{spanId1}:start": "timestamp",
  "{spanId1}:end": "timestamp",
  "{spanId2}:start": "timestamp",
  "{spanId2}:end": "timestamp",
  ...
}
```

lua 脚本传入此次会议室需要操作的时间段 spanId 和该 span 占用的时间，查询得到当前占用的所有时间段，如果有冲突则返回“会议室正在被操作”，无冲突，则写入时间段
